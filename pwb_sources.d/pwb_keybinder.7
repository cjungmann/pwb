.TH pwb_keybinder 7
.mso gproto.tmac
.SH NAME
.B pwb_keybinder
\- Process array to create KEYMAP, Help page, and execute page
.SH SYNOPSIS
.PP
.B pwb_keybinder
.cli_prototype @action @binddef_array ?!-v:return_value_name ?!-f:keyfunc_array
.SH DESCRIPTION
.PP
This is a code-saving that can handle
.BR keymap ", " help-page ", and " " function retrieval"
tasks when provided with an appropriate array of keybinding
information.
.PP

.SH OPTIONS
.TP
.I action
determines how the keybinding information will be used.
The allowed values are
.BR help ", " hlines ", " prep ", and " func .
.RS 8
.TP
.B help
Generates a help message from the keybinding array.  It will
add a
.B q
for help line and wait for a user response.
.IP
If the call includes a
.BR "-v \fIreturn_value_name\fP" ,
the keypress that terminated the dialog will be returned in that
variable for consideration.  That usually means the script can
execute the command if it's one of the keybindings.
.TP
.B hlines
Returns an array of lines that can be used with
.BR pwb_print_message " or " pwb_conduct_dialog .
This version does not include the
.B q
option.  It must be added for it to be included in the message.
.IP
Look at the example, function
.BR show_custom_help .
.TP
.B prep
Using the keybinding array, this action will create a keymap that
can be used with
.BR "pwb start" .
.TP
.B func
Will search for a matching key in the keybinding array.  If the
keystroke is matched, the name of the associated function will be
returned, and the
.B pwb_keybinder
function will return 0 (true).
.IP
In most cases, use a transformed
.I binddef_array
to enable this action to recognize keys that were defined as key
names instead of ANSI keystroke strings.  See
.BI "-f " keyfunc_array

.RE
.TP
.I binddef_array
is an array of values, arranged in groups of three
.RI ( key ", " function ", and " label ),
that define a key binding.
This array is then used to prepare a keymap, display a help message,
or return the function bound to a keystroke.
.IP
The
.I key
value can be a single character, an ANSI string, or a key's
C variable name as defined in
.BR terminfo (5),
such as
.BR key_f1 " or " key_npage .
.IP
The
.I function
value is the name of the function that should be called when the
associated key is pressed.
.IP
The
.I label
value is a string to use in the help display to describe the key.

.IP
Look in the
.B EXAMPLE
below for how to setup a
.IR binddef_array ,
including using keynames as suggested in the
.BI "-f " keyfunc_array
option documentation.
.TP
.BI "-v " return_value_name
The name of a variable in which the action's result will be returned.
This is optional only because the
.B help
action doesn't require it.  Look at the
.I action
option above to see what each action returns.
.IP
For actions that require a
.IR return_value_name ,
an error message will display if the name is not provided.
.TP
.BI "-f " keyfunc_array
is an optional array name that, if provided, will be filled with
an transformed
.I binddef_array
that replaces keynames with ANSI keystroke strings.
.IP
If provided, use the
.I keyfunc_array
with the
.B func
action to retrieve functions associated with the ANSI keystrokes
instead of keynames.
.IP
If providing an
.B -f
option, use the source
.I binddef_array
for generating help messages and use the transformed keybinding
array for calling the
.B func
action.
.SH USING KEYNAMES
.PP
It is a tedious and error-exposed process to look up and type in
the ANSI strings associated with the non-character keys.  It is far
easier to use key names.
.PP
However, if key names are used, it will be necessary to also use the
.BI "-f " keyfunc_array
option to generate a key array with the ANSI strings that are needed
for the
.B func
action.
.PP
Look up the key names in the
.BR terminfo (5)
man page or by using the
.B infocmp
command.  Get the list of recognized key names with:
.IP
.EX
infocmp -1L | grep key_[^=]+
.EE
.PP
or by using the
.B pwb_samples
script
.BR pwb_termcap ,
which also shows the description from the terminfo man page.
.PP
Some of the key C variable and special names are not obvious:
.TS
tab(|);
l l.
key_up|up-arrow key
key_down|down-arrow key
key_left|left-arrow key
key_right|right-arrow key
key_npage|page down key
key_ppage|page up key
key_escape|ESC key
\(Do\(aq\(rscm\(aq|Enter key
.TE
.PP
In some cases, a leading
.RB \(aq s \(aq
can indicate a shifted key.  For example,
.B key_shome
refers to pressing a shifted
.B home
key.
Most keys do not have an
.RB \(aq s \(aq
variant, however.
.SS SPECIAL CASE KEYS
.PP
The terminfo entries do not include either the Escape key or the
main Enter key
.RB ( key_enter
refers to the keypad Enter key).
.B pwb_keybinder
will recognize these keys with variable names
.BR key_escape " and " \(Do\(aq\(rscm\(aq
as shown in the table, providing the appropriate ANSI value and
label string where needed.

.SH EXAMPLE
.PP
.EX
\(sh!/usr/bin/env bash
show_help()
{
   \fBpwb_keybinder help\fR KEYBINDINGS
}

show_custom_help()
{
   local -a sh_lines
   \fBpwb_keybinder hlines\fR KEYBINDINGS -v sh_lines
   sh_lines+=(
      \(dq\(dq
      \(dqPress q to quit\(dq
      \(dqPress any key to continue\(dq
   )
   pwb_print_message sh_lines
   read -n1
}

show_info()
{
   local si_item=\(dq\(Do1\(dq
   local -a si_lines=(
      \(dqInformation on \(Dosi_item\(dq
      \(dqNothing too interesting.\(dq
      \(dq\(dq
      \(dqPress any key to continue\(dq
   )
   pwb_print_message si_lines
   read -n1
}

print_line()
{
   local -n pl_dsource=\(dq\(Do2\(dq
   local pl_line=\(dq\(Do{pl_dsource[\(Do1]}\(dq
   printf \(dq%-*.*s\(dq \(dq\(Do3\(dq \(dq\(Do3\(dq \(dq\(Dopl_line\(dq
}

execute_line()
{
   local keyp=\(dq\(Do1\(dq
   local -n el_dsource=\(dq\(Do3\(dq
   local item=\(dq\(Do{el_dsource[\(Do2]}\(dq
   local phandle=\(dq\(Do4\(dq

   local -i ecode=0

   if \fBpwb_keybinder func\fR KEYFUNCS -v el_func -k \(dq\(Dokeyp\(dq; then
      \(Doel_func \(dq\(Doitem\(dq
      ecode=\(dq\(Do?\(dq
      printf \(Do\(aq\(rse[2J\(aq
      pwb print_all \(dq\(Dophandle\(dq
   fi

   return \(dq\(Doecode\(dq
}

enable pwb
source <( pwb_sources pwb_keybinder pwb_print_message )

\(sh Make global array for frequent and varying access:
declare -a KEYBINDINGS=(
   \(dq?\(dq       show_help   \(dqShow help\(dq
   \(dqkey_f1\(dq  show_help   \(dqShow help\(dq
   \(dqi\(dq       show_info   \(dqInspect item\(dq
   \(Do\(aq\(rscm\(aq    show_info   \(dqInspect item\(dq \(sh Control-M/ENTER KEY
)

declare KEYMAP
declare -a KEYFUNCS
\fBpwb_keybinder prep\fR KEYBINDINGS -v KEYMAP -f KEYFUNCS

declare -a FILES=( * )

declare PHANDLE
pwb declare PHANDLE FILES \(dq\(Do{\(shFILES[*]}\(dq print_line -e execute_line

pwb init

\(sh Show second of two pwb_keybinder help methods
show_custom_help

pwb start PHANDLE -a KEYMAP
pwb restore
.EE
