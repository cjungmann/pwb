# -*- mode:shell-script; sh-shell:bash  -*-
# shellcheck shell=bash
# shellcheck disable=SC2317

#> pwb_read_args args_array_name [var_names_array_name] [opts_list_name]
#> see test_read_args script for examples

pwb_read_args()
{
    show_usage()
    {
        fit_the_print()
        {
            local tline="$1"
            pwb measure_string curlen "$tline"
            if (( curlen + curpos < maxlen )); then
                printf "%s" "$tline"
            else
                printf $'\n\e[%dC%s' "$indent" "$tline"
            fi
        }

        local fname="$1"
        local -n su_arg_names="$2"
        local -n su_opts_list="$3"

        local -i indent=$(( 2 + "${#fname}" ))
        local -i maxlen=80

        local col_bold="${LESS_TERMCAP_md}"
        if [ -z "$col_bold" ]; then col_bold=$'\e[34;1m'; fi
        local col_ital="${LESS_TERMCAP_us}"
        if [ -z "$col_ital" ]; then col_ital=$'\e[32;1m'; fi
        local col_none=$'\e[m'

        printf "\nUSAGE for $fname:\n"
        printf "  %s " "$fname"
        for s in "${BASH_SOURCE[@]}"; do
            printf "  %2d: %s\n" "$bs_count" "${BASH_SOURCE[$bs_count]}"
            (( ++bs_count ))
        done

        local -i count_flags=0
        local -i curlen curpos="$indent"
        local tline
        local trigger name
        for el in "${su_opts_list[@]}"; do
            if [ -z "$trigger" ]; then
                trigger="$el"
            else
                if [ "${#trigger}" -gt 1 ]; then
                    printf -v tline \
                           " ${col_bold}-%s${col_none} ${col_ital}%s${col_none}" \
                           "${trigger:0:1}" "$el"
                else
                    # Flags need further info, count 'em to show the extra later:
                    (( ++count_flags ))
                    printf -v tline " ${col_bold}-%s${col_none}" "${trigger:0:1}"
                fi

                fit_the_print "$tline"
                trigger=""
            fi
        done

        for arg in "${su_arg_names[@]}"; do
            printf -v tline " ${col_ital}%s${col_none}" "$arg"
            fit_the_print "$tline"
        done

        if (( count_flags > 0 )); then
            printf "Flag variables:\n"
            for el in "${su_opts_list[@]}"; do
                if [ -z "$trigger" ]; then
                    trigger="$el"
                else
                    if [ "${#trigger}" -eq 1 ]; then
                        printf "  ${col_bold}%-s${col_none} ${col_ital}%s${col_none}\n" \
                               "$trigger" "$el"
                    fi
                    trigger=""
                fi
            done
        fi

        # Set off from following prompt
        echo
    }

    # Value returned in variable named in $1 indicates how to continue:
    # If it's blank, we're done with the argument, if it has a value,
    # it's the name of the variable to set from the next argument.
    get_option_entry()
    {
        local -n goe_name="$1"
        # Clear goe_name as signal it shouldn't be changed,
        # which might be because it is a flag whose value
        # will have already been set upon return
        goe_name=""

        # Trim off leading '-' so chars can be considered individually
        local option_arg="${2:1}"

        local opt_flag
        # For each option letter of the option arg, seek an options list match.
        # Use remainder of option characters as the option value if the option
        # takes an option value rather than used to set a flag:
        while [ "${#option_arg}" -gt 0 ]; do

            # Search opts_list for matching option flag/name pair
            for el in "${pra_opts_list[@]}"; do

                # It's a two-part search, so the first time we just get
                # the option letter, the following time through gets the
                # target variable name
                if [ -z "$opt_flag" ]; then
                    opt_flag="$el"
                    continue
                # Second time through, we have enough to work
                else
                    # Save and clear opt_flag for next pair search
                    local opt_name="$opt_flag"
                    opt_flag=""

                    # Compare first letters to find a match
                    if [[ "${opt_name:0:1}" == "${option_arg:0:1}" ]]; then
                        # If the option is a flag (it's one char lone),
                        # set it, update option_arg, and continue:
                        if [ "${#opt_name}" -eq 1 ]; then
                            local -n tval="$el"

                            # Caller's reponsibility to clear values before calling:
                            if (( tval != 0 )); then
                                read -s -n1 -p "Variable '$el' should have been preset to 0"
                                # Do not tolerate arguments mistakes committed by script
                                # function caller:
                                exit 1
                            else
                                tval=1
                                # Remove matched flag char in order to process the next one
                                option_arg="${option_arg:1}"
                                # return to outer loop for next character
                                continue 2
                            fi
                        # The option takes an value
                        else
                            # If chars follow value-taking option, they are the value.
                            # save the remainder directly to the target variable and leave
                            #    just save the rest
                            if [ "${#option_arg}" -gt 1  ]; then
                                local -n tval="$el"
                                tval="${option_arg:1}"
                            # If the current char is the last, the value will be in the
                            # next argument.  Return the variable name to be set with the
                            # with the next argument:
                            else
                                goe_name="$el"
                            fi

                            # break out of outer loop to finish early
                            break 2
                        fi
                        break
                    fi
                fi
            done

            echo "Unrecognized option '-${option_arg:0:1}' from '$option_arg'"
            exit 1
        done
    }

    #################################
    ###   EXECUTION BEGINS HERE   ###
    #################################


    # empty array whose name will be used missing array names
    local -a pra_empty=()

    local -n pra_command_args="$1"

    local -n pra_arg_names="${2:-pra_empty}"
    local -n pra_opts_list="${3:-pra_empty}"

    # Show usage and return if environment var is set:
    if [ -n "$PWB_READ_ARGS_SHOW_USAGE" ]; then
        show_usage "${FUNCNAME[1]}" pra_arg_names pra_opts_list
        return 0
    fi

    local -i opts_count="${#pra_opts_list[@]}"
    # Minimally validate opts array contents
    if (( opts_count % 2 != 0 )); then
        echo "Invalid array of opt args (must be paired ($opts_count))"
        read -n1 -p "opts are ${pra_opts_list[*]}"
        # Do not tolerate arguments mistakes committed by script function caller
        exit 1
    fi

    local -i option_parsing=1
    still_processing_options() { [ "$option_parsing" -eq 1 ]; }

    local -i args_index=0
    local -i args_count="${#pra_arg_names[@]}"
    local opt_name
    for arg in "${pra_command_args[@]}"; do
        # Value arg of '-o' 'value' pair
        if [ -n "$opt_name" ]; then
            local -n tvar="$opt_name"
            tvar="$arg"
            opt_name=""
        # '-' prefix starts option processing
        # elif still_processing_options && [[ "$arg" =~ ^-..? ]]; then
        elif still_processing_options && [[ "$arg" =~ ^-..? ]]; then
            if [[ "$arg" == "--" ]]; then
                option_parsing=0
                continue
            else
                # if 'opt_name' is set on return, opt_name is the variable
                # to set with the value of the next CL argument
                get_option_entry opt_name "$arg"
            fi
        # not an option, set next positional argument
        elif (( args_index < args_count )); then
            local argname="${pra_arg_names[$args_index]}"
            local -n tvar="$argname"
            tvar="$arg"
            (( ++args_index ))
        fi
    done

    return 0
}
