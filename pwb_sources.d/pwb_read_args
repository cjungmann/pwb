# -*- mode:shell-script; sh-shell:bash  -*-
# shellcheck shell=bash
# shellcheck disable=SC2317

#> pwb_read_args args_array_name [var_names_array_name] [opts_list_name]
#> see test_read_args script for examples

pwb_read_args()
{
    show_usage()
    {
        fit_the_print()
        {
            local tline="$1"
            pwb measure_string curlen "$tline"
            if (( curlen + curpos < maxlen )); then
                printf "%s" "$tline"
            else
                printf $'\n\e[%dC%s' "$indent" "$tline"
            fi
        }

        local fname="$1"
        local -n su_arg_names="$2"
        local -n su_opts_list="$3"

        local -i indent=$(( 2 + "${#fname}" ))
        local -i maxlen=80

        local col_bold="${LESS_TERMCAP_md}"
        if [ -z "$col_bold" ]; then col_bold=$'\e[34;1m'; fi
        local col_ital="${LESS_TERMCAP_us}"
        if [ -z "$col_ital" ]; then col_ital=$'\e[32;1m'; fi
        local col_none=$'\e[m'

        printf "\nUSAGE for $fname:\n"
        printf "  %s" "$fname"

        local -i count_flags=0
        local -i curlen curpos="$indent"
        local tline
        local trigger name
        for el in "${su_opts_list[@]}"; do
            if [ -z "$trigger" ]; then
                trigger="$el"
            else
                if [ "${#trigger}" -gt 1 ]; then
                    printf -v tline \
                           " ${col_bold}-%s${col_none} ${col_ital}%s${col_none}" \
                           "${trigger:0:1}" "$el"
                else
                    # Flags need further info, count 'em to show the extra later:
                    (( ++count_flags ))
                    printf -v tline " ${col_bold}-%s${col_none}" "${trigger:0:1}"
                fi

                fit_the_print "$tline"
                trigger=""
            fi
        done

        for arg in "${su_arg_names[@]}"; do
            printf -v tline " ${col_ital}%s${col_none}" "$arg"
            fit_the_print "$tline"
        done

        if (( count_flags > 0 )); then
            printf "Flag variables:\n"
            for el in "${su_opts_list[@]}"; do
                if [ -z "$trigger" ]; then
                    trigger="$el"
                else
                    if [ "${#trigger}" -eq 1 ]; then
                        printf "  ${col_bold}%-s${col_none} ${col_ital}%s${col_none}\n" \
                               "$trigger" "$el"
                    fi
                    trigger=""
                fi
            done
        fi

        # Set off from following prompt
        echo
    }

    # Value returned in variable named in $1 indicates how to continue:
    # If it's blank, we're done with the argument, if it has a value,
    # it's the name of the variable to set from the next argument.
    get_option_entries()
    {
        # Clear goe_name as signal it shouldn't be changed,
        # which might be because it is a flag whose value
        # will have already been set upon return
        local -n goe_rname="$1"
        goe_rname=""

        # Trim off leading '-' so chars can be considered individually
        local option_progress="${2:1}"

        local opt_flag
        # For each option letter of the option arg, seek an options list match.
        # Use remainder of option characters as the option value if the option
        # takes an option value rather than used to set a flag:
        while [ "${#option_progress}" -gt 0 ]; do

            # Search opts_list for matching option flag/name pair
            for el in "${pa_opts_list[@]}"; do
                # It's a two-part search, so the first time we just get
                # the option letter, the following time through gets the
                # target variable name
                if [ -z "$opt_flag" ]; then
                    opt_flag="$el"
                    continue
                # Second time through, we have enough to work
                else
                    # Save and clear opt_flag to permit break or continue
                    local goe_opt_name="$opt_flag"
                    opt_flag=""

                    # Compare first letters to find a match
                    if [[ "${goe_opt_name:0:1}" == "${option_progress:0:1}" ]]; then
                        # If the option is a flag (it's one char lone),
                        # set it, update option_progress, and continue:
                        if [ "${#goe_opt_name}" -eq 1 ]; then
                            local -n tval="$el"

                            # Caller's reponsibility to clear values before calling:
                            if (( tval != 0 )); then
                                read -s -n1 -p "Variable '$el' should have been preset to 0"
                                # Do not tolerate arguments mistakes committed by script
                                # function caller:
                                exit 1
                            else
                                tval=1
                                # Remove matched flag char in order to process the next one
                                option_progress="${option_progress:1}"
                                # return to outer loop for next character
                                continue 2
                            fi
                        # The option takes an value
                        else
                            # If chars follow value-taking option, they are the value.
                            # save the remainder directly to the target variable and leave
                            #    just save the rest
                            if [ "${#option_progress}" -gt 1  ]; then
                                local -n tval="$el"
                                tval="${option_progress:1}"
                            # If the current char is the last, the value will be in the
                            # next argument.  Return the variable name to be set with the
                            # with the next argument:
                            else
                                goe_rname="$el"
                            fi

                            # break out of outer loop to finish early
                            break 2
                        fi
                        break
                    fi
                fi
            done

            if [ -z "$PWB_READ_ARGS_SILENTLY" ]; then
                echo "Unrecognized option '-${option_progress:0:1}' from '$option_progress'"
                exit 1
            else
                option_progress="${option_progress:1}"
            fi
        done
    }

    parse_args()
    {
        local -n pa_command_args="$1"
        local -n pa_arg_names="$2"
        local -n pa_opts_list="$3"

        local -i opts_count="${#pa_opts_list[@]}"
        # Minimally validate opts array contents
        if (( opts_count % 2 != 0 )); then
            echo "Invalid array of opt args (must be paired ($opts_count))"
            read -n1 -p "opts are ${pa_opts_list[*]}"
            # Do not tolerate arguments mistakes committed by script function caller
            exit 1
        fi

        # Flag to clear when encounterin '--', following which arguments
        # will be treated as values, even if they look like an option.
        local -i option_parsing=1
        still_processing_options() { [ "$option_parsing" -eq 1 ]; }

        local -i args_index=0
        local -i args_count="${#pa_arg_names[@]}"
        local opt_name
        local -i clas_index=0
        for arg in "${pa_command_args[@]}"; do
            # If previous pass identified an option that sets a value,
            # set the value and clear the opt_name variable.
            if [ -n "$opt_name" ]; then
                local -n tvar="$opt_name"
                tvar="$arg"
                opt_name=""
            # '-' prefix starts option processing
            # elif still_processing_options && [[ "$arg" =~ ^-..? ]]; then
            elif still_processing_options && [[ "$arg" =~ ^-..? ]]; then
                if [[ "$arg" == "--" ]]; then
                    option_parsing=0
                else
                    # if 'opt_name' is set on return, opt_name is the variable
                    # to set with the value of the next CL argument
                    get_option_entries opt_name "$arg"
                fi
                # not an option, set next positional argument
            elif (( args_index < args_count )); then
                local argname="${pa_arg_names[$args_index]}"
                local -n tvar="$argname"
                tvar="$arg"
                (( ++args_index ))
            else
                continue # without discarding the argument
            fi

            # Discard any consumed arguments
            unset pa_command_args[$(( clas_index++ ))]
        done
    }

    #################################
    ###   EXECUTION BEGINS HERE   ###
    #################################

    local -a empty_array=()
    local command_args_array="${1:-empty_array}"
    local arg_names_array="${2:-empty_array}"
    local opts_list_array="${3:-empty_array}"

    # Show usage and return if environment var is set:
    if [ -n "$PWB_READ_ARGS_SHOW_USAGE" ]; then
        local funcname="${FUNCNAME[@]: -2:1}"

        # Using FUNCNAME[0]} to protect against renaming this script:
        if [[ "$funcname" == "${FUNCNAME[0]}" ]]; then
            local -a arg_names=(
                command_args_array
                arg_names_array
                opts_list_array
            )
            show_usage "$funcname" arg_names empty_array
        else
            show_usage "$funcname" "$arg_names_array" "$opts_list_array"
        fi
        return 1
    else
        parse_args "$command_args_array" "$arg_names_array" "$opts_list_array"
        return "$?"
    fi
}

