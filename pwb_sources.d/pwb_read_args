# -*- mode:shell-script; sh-shell:bash  -*-
# shellcheck shell=bash
# shellcheck disable=SC2317

#> pwb_read_args args_array_name [var_names_array_name] [opts_list_name]
#> see test_read_args script for examples

pwb_read_args()
{
    # Value returned in variable named in $1 indicates how to continue:
    # If it's blank, we're done with the argument, if it has a value,
    # it's the name of the variable to set from the next argument.
    get_option_entry()
    {
        local -n goe_name="$1"
        # Clear goe_name as signal it shouldn't be changed,
        # which might be because it is a flag whose value
        # will have already been set upon return
        goe_name=""

        # Trim off leading '-' so chars can be considered individually
        local option_arg="${2:1}"

        local opt_flag
        # For each option letter of the option arg, seek an options list match.
        # Use remainder of option characters as the option value if the option
        # takes an option value rather than used to set a flag:
        while [ "${#option_arg}" -gt 0 ]; do

            # Search opts_list for matching option flag/name pair
            for el in "${pra_opts_list[@]}"; do

                # It's a two-part search, so the first time we just get
                # the option letter, the following time through gets the
                # target variable name
                if [ -z "$opt_flag" ]; then
                    opt_flag="$el"
                    continue
                # Second time through, we have enough to work
                else
                    # Save and clear opt_name for next pair search
                    local opt_name="$opt_flag"
                    opt_flag=""

                    # Compare first letters to find a match
                    if [[ "${opt_name:0:1}" == "${option_arg:0:1}" ]]; then
                        # Option is a flag, set it, update option_arg and continue
                        if [ "${#opt_name}" -gt 1 ]; then
                            local -n tval="$el"

                            # Caller's reponsibility to clear values before calling:
                            if (( tval != 0 )); then
                                read -s -n1 -p "Variable '$el' should have been preset to 0"
                                # Do not tolerate arguments mistakes committed by script
                                # function caller:
                                exit 1
                            else
                                tval=1
                                # Remove matched flag char in order to process the next one
                                option_arg="${option_arg:1}"
                                # return to outer loop for next character
                                continue 2
                            fi
                        # The option takes an value
                        else
                            # If chars follow value-taking option, they are the value.
                            # save the remainder directly to the target variable and leave
                            #    just save the rest
                            if [ "${#option_arg}" -gt 1  ]; then
                                local -n tval="$el"
                                tval="${option_arg:1}"
                            # If the current char is the last, the value will be in the
                            # next argument.  Return the variable name to be set with the
                            # with the next argument:
                            else
                                goe_name="$el"
                            fi

                            # break out of outer loop to finish early
                            break 2
                        fi
                        break
                    fi
                fi
            done

            echo "Unrecognized option '-${option_arg:0:1}' from '$option_arg'"
            exit 1
        done
    }

    #################################
    ###   EXECUTION BEGINS HERE   ###
    #################################


    # empty array whose name will be used missing array names
    local -a pra_empty=()

    local -n pra_command_args="$1"

    local -n pra_arg_names="${2:-pra_empty}"
    local -n pra_opts_list="${3:-pra_empty}"

    local -i opts_count="${#pra_opts_list[@]}"
    # Minimally validate opts array contents
    if (( opts_count % 2 != 0 )); then
        echo "Invalid array of opt args (must be paired ($opts_count))"
        read -n1 -p "opts are ${pra_opts_list[*]}"
        # Do not tolerate arguments mistakes committed by script function caller
        exit 1
    fi

    local -i option_parsing=1
    still_processing_options() { [ "$option_parsing" -eq 1 ]; }

    local -i args_index=0
    local -i args_count="${#pra_arg_names[@]}"
    local opt_name
    for arg in "${pra_command_args[@]}"; do
        # Value arg of '-o' 'value' pair
        if [ -n "$opt_name" ]; then
            echo "Setting '$opt_name' to '$arg'"
            local -n tvar="$opt_name"
            tvar="$arg"
            opt_name=""
        # '-' prefix starts option processing
        # elif still_processing_options && [[ "$arg" =~ ^-..? ]]; then
        elif still_processing_options && [[ "$arg" =~ ^-..? ]]; then
            if [[ "$arg" == "--" ]]; then
                option_parsing=0
                continue
            else
                # if 'opt_name' is set on return, opt_name is the variable
                # to set with the value of the next CL argument
                get_option_entry opt_name "$arg"
            fi
        # not an option, set next positional argument
        elif (( args_index < args_count )); then
            local argname="${pra_arg_names[$args_index]}"
            local -n tvar="$argname"
            tvar="$arg"
            (( ++args_index ))
        fi
    done

    return 0
}
